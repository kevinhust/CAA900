name: Deploy JobQuest Navigator v3 Production Application

on:
  push:
    branches: [ main ]
    paths:
      - 'JNv3/**'
      - '.github/workflows/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
        - production

env:
  AWS_REGION: us-east-1
  PROJECT_NAME: jobquest-navigator-v3

jobs:
  deploy-infrastructure:
    name: Deploy AWS Infrastructure
    runs-on: ubuntu-latest
    environment: production
    
    outputs:
      backend_repo_url: ${{ steps.terraform-outputs.outputs.backend_repo_url }}
      frontend_repo_url: ${{ steps.terraform-outputs.outputs.frontend_repo_url }}
      application_url: ${{ steps.terraform-outputs.outputs.application_url }}
      cluster_name: ${{ steps.terraform-outputs.outputs.cluster_name }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: '1.6.0'
        terraform_wrapper: false
    
    - name: Terraform Format Check
      run: |
        cd JNv3/infrastructure/terraform
        terraform fmt -check -diff || {
          echo "‚ùå Terraform files are not properly formatted!"
          echo "Run 'terraform fmt' to fix formatting issues."
          exit 1
        }
    
    - name: Terraform Init
      run: |
        cd JNv3/infrastructure/terraform
        terraform init -backend-config=backend-configs/production.hcl -input=false
    
    - name: Terraform Validate
      run: |
        cd JNv3/infrastructure/terraform
        terraform validate
    
    - name: Terraform Refresh State
      env:
        TF_VAR_project_name: ${{ env.PROJECT_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
      run: |
        cd JNv3/infrastructure/terraform
        echo "üîÑ Refreshing Terraform state to match AWS resources..."
        terraform refresh -input=false
    
    - name: Terraform Plan
      id: plan
      env:
        TF_VAR_project_name: ${{ env.PROJECT_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
      run: |
        cd JNv3/infrastructure/terraform
        terraform plan -input=false -no-color -out=tfplan
        echo "plan_exitcode=$?" >> $GITHUB_OUTPUT
    
    - name: Show Terraform Plan Summary
      run: |
        cd JNv3/infrastructure/terraform
        echo "## üìã Terraform Plan Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
        terraform show -no-color tfplan | head -50 >> $GITHUB_STEP_SUMMARY
        echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
    
    - name: Terraform Apply
      if: github.ref == 'refs/heads/main' && steps.plan.outputs.plan_exitcode == '0'
      env:
        TF_VAR_project_name: ${{ env.PROJECT_NAME }}
        TF_VAR_aws_region: ${{ env.AWS_REGION }}
        TF_VAR_secret_key: ${{ secrets.SECRET_KEY }}
      run: |
        cd JNv3/infrastructure/terraform
        echo "üöÄ Applying Terraform plan to production..."
        terraform apply -input=false -no-color tfplan
        
        if [ $? -eq 0 ]; then
          echo "‚úÖ Infrastructure deployment successful!"
        else
          echo "‚ùå Infrastructure deployment failed!"
          exit 1
        fi
    
    - name: Get deployment outputs
      id: terraform-outputs
      run: |
        cd JNv3/infrastructure/terraform
        echo "backend_repo_url=$(terraform output -raw backend_ecr_repository_url 2>/dev/null || echo 'Not available')" >> $GITHUB_OUTPUT
        echo "frontend_repo_url=$(terraform output -raw frontend_ecr_repository_url 2>/dev/null || echo 'Not available')" >> $GITHUB_OUTPUT
        echo "application_url=$(terraform output -raw application_url 2>/dev/null || echo 'Not available')" >> $GITHUB_OUTPUT
        echo "cluster_name=$(terraform output -raw ecs_cluster_name 2>/dev/null || echo 'Not available')" >> $GITHUB_OUTPUT

    - name: Notify on Failure
      if: failure()
      run: |
        echo "## ‚ùå Infrastructure Deployment Failed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Error occurred during infrastructure deployment.**" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Debug Steps:**" >> $GITHUB_STEP_SUMMARY
        echo "1. Check Terraform plan output above" >> $GITHUB_STEP_SUMMARY
        echo "2. Verify AWS credentials and permissions" >> $GITHUB_STEP_SUMMARY
        echo "3. Check for resource conflicts or limits" >> $GITHUB_STEP_SUMMARY
        echo "4. Review backend state configuration" >> $GITHUB_STEP_SUMMARY

  build-and-push-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: deploy-infrastructure
    if: success()
    environment: production
    
    outputs:
      backend_image_tag: ${{ steps.build-info.outputs.backend_image_tag }}
      frontend_image_tag: ${{ steps.build-info.outputs.frontend_image_tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        platforms: linux/amd64
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Set image tags
      id: build-info
      run: |
        echo "IMAGE_TAG=build-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        echo "backend_image_tag=build-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
        echo "frontend_image_tag=build-$(date +%Y%m%d-%H%M%S)-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
    
    - name: Build, tag, and push backend image to Amazon ECR
      working-directory: ./JNv3/apps/backend-fastapi
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.PROJECT_NAME }}-backend
        IMAGE_TAG: ${{ steps.build-info.outputs.IMAGE_TAG }}
      run: |
        echo "üî® Building backend image for AMD64 platform..."
        docker buildx build \
          --platform linux/amd64 \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --push .
        echo "‚úÖ Backend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    
    - name: Build, tag, and push frontend image to Amazon ECR
      working-directory: ./JNv3/apps/frontend-react
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY: ${{ env.PROJECT_NAME }}-frontend
        IMAGE_TAG: ${{ steps.build-info.outputs.IMAGE_TAG }}
      run: |
        echo "üî® Building frontend image for AMD64 platform..."
        docker buildx build \
          --platform linux/amd64 \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
          --tag $ECR_REGISTRY/$ECR_REPOSITORY:latest \
          --push .
        echo "‚úÖ Frontend image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

    - name: Image Build Summary
      run: |
        echo "## üê≥ Docker Images Built Successfully" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Backend Image:** \`${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}-backend:${{ steps.build-info.outputs.IMAGE_TAG }}\`" >> $GITHUB_STEP_SUMMARY
        echo "**Frontend Image:** \`${{ steps.login-ecr.outputs.registry }}/${{ env.PROJECT_NAME }}-frontend:${{ steps.build-info.outputs.IMAGE_TAG }}\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Platform:** linux/amd64 (ECS Fargate compatible)" >> $GITHUB_STEP_SUMMARY

  update-ecs-services:
    name: Update ECS Services
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, build-and-push-images]
    if: success()
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Force new deployment for backend service
      run: |
        echo "üîÑ Triggering backend service deployment..."
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --service ${{ env.PROJECT_NAME }}-backend-service \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        echo "‚úÖ Backend service deployment triggered"
    
    - name: Force new deployment for frontend service
      run: |
        echo "üîÑ Triggering frontend service deployment..."
        aws ecs update-service \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --service ${{ env.PROJECT_NAME }}-frontend-service \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        echo "‚úÖ Frontend service deployment triggered"
    
    - name: Wait for services to stabilize
      run: |
        echo "‚è≥ Waiting for services to stabilize..."
        
        echo "Waiting for backend service..."
        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --services ${{ env.PROJECT_NAME }}-backend-service \
          --region ${{ env.AWS_REGION }}
        
        echo "Waiting for frontend service..."
        aws ecs wait services-stable \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --services ${{ env.PROJECT_NAME }}-frontend-service \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ All services are stable"
    
    - name: Check service health
      run: |
        echo "üè• Checking service health..."
        
        # Get service status
        BACKEND_STATUS=$(aws ecs describe-services \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --services ${{ env.PROJECT_NAME }}-backend-service \
          --query 'services[0].[runningCount,desiredCount]' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        FRONTEND_STATUS=$(aws ecs describe-services \
          --cluster ${{ env.PROJECT_NAME }}-cluster \
          --services ${{ env.PROJECT_NAME }}-frontend-service \
          --query 'services[0].[runningCount,desiredCount]' \
          --output text \
          --region ${{ env.AWS_REGION }})
        
        echo "Backend Service: $BACKEND_STATUS"
        echo "Frontend Service: $FRONTEND_STATUS"
        
        echo "## üöÄ Service Deployment Status" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Backend Service:** $BACKEND_STATUS" >> $GITHUB_STEP_SUMMARY
        echo "**Frontend Service:** $FRONTEND_STATUS" >> $GITHUB_STEP_SUMMARY

  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    needs: [deploy-infrastructure, update-ecs-services]
    if: success()
    
    steps:
    - name: Test application endpoints
      run: |
        APP_URL="${{ needs.deploy-infrastructure.outputs.application_url }}"
        
        echo "üåê Testing application endpoints..."
        
        # Test frontend
        echo "Testing frontend..."
        FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${APP_URL}/" || echo "000")
        echo "Frontend status: $FRONTEND_STATUS"
        
        # Test backend health
        echo "Testing backend health..."
        BACKEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${APP_URL}/api/health" || echo "000")
        echo "Backend health status: $BACKEND_STATUS"
        
        # Test GraphQL endpoint
        echo "Testing GraphQL endpoint..."
        GRAPHQL_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${APP_URL}/graphql" || echo "000")
        echo "GraphQL status: $GRAPHQL_STATUS"
        
        echo "## üéØ Deployment Validation Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Application URL:** $APP_URL" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "| Endpoint | Status | Result |" >> $GITHUB_STEP_SUMMARY
        echo "|----------|--------|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Frontend | HTTP $FRONTEND_STATUS | $([ "$FRONTEND_STATUS" -eq 200 ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Check needed") |" >> $GITHUB_STEP_SUMMARY
        echo "| Backend API | HTTP $BACKEND_STATUS | $([ "$BACKEND_STATUS" -eq 200 ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Check needed") |" >> $GITHUB_STEP_SUMMARY
        echo "| GraphQL | HTTP $GRAPHQL_STATUS | $([ "$GRAPHQL_STATUS" -eq 200 ] && echo "‚úÖ Healthy" || echo "‚ö†Ô∏è Check needed") |" >> $GITHUB_STEP_SUMMARY
        
        # Summary
        if [ "$FRONTEND_STATUS" = "200" ] && [ "$BACKEND_STATUS" = "200" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "üéâ **Deployment Successful!** All services are healthy and accessible." >> $GITHUB_STEP_SUMMARY
        else
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "‚ö†Ô∏è **Deployment completed but some services need attention.** Check the endpoint statuses above." >> $GITHUB_STEP_SUMMARY
        fi

    - name: Deployment success notification
      if: success()
      run: |
        echo "## üéâ Deployment Completed Successfully!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**JobQuest Navigator v3** has been deployed to production:" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "üåê **Access your application:** ${{ needs.deploy-infrastructure.outputs.application_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**What was deployed:**" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ AWS Infrastructure (Terraform)" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ FastAPI Backend with GraphQL" >> $GITHUB_STEP_SUMMARY  
        echo "- ‚úÖ React 19 Frontend" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ PostgreSQL Database" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ Application Load Balancer" >> $GITHUB_STEP_SUMMARY
        echo "- ‚úÖ ECS Fargate Services" >> $GITHUB_STEP_SUMMARY

    - name: Rollback on failure
      if: failure()
      run: |
        echo "‚ùå Deployment validation failed. Consider manual rollback if needed."
        echo "## ‚ùå Deployment Validation Failed" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "The deployment completed but validation checks failed." >> $GITHUB_STEP_SUMMARY
        echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY  
        echo "1. Check ECS service logs in CloudWatch" >> $GITHUB_STEP_SUMMARY
        echo "2. Verify container health and startup logs" >> $GITHUB_STEP_SUMMARY
        echo "3. Check Application Load Balancer target group health" >> $GITHUB_STEP_SUMMARY
        echo "4. Consider manual rollback if necessary" >> $GITHUB_STEP_SUMMARY